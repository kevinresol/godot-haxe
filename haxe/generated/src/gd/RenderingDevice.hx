package gd;
class RenderingDevice extends gd.Object {
	public function new(?native:cpp.Pointer<gdnative.RenderingDevice.RenderingDevice_extern>) {
		if (native == null) {
			gd.Utils.checkAndWarnForMissingOwner(this, "RenderingDevice");
			trace("Allocating RenderingDevice");
			native = gdnative.RenderingDevice.RenderingDevice_extern.__alloc();
		};
		super(native.reinterpret());
	}
	extern inline function __renderingdevice_ptr():cpp.Pointer<gdnative.RenderingDevice.RenderingDevice_extern> return cast __gd.ptr;
	public function texture_create_shared(p_view:gd.RDTextureView, p_with_texture:gd.RID):gd.RID return __renderingdevice_ptr().value.texture_create_shared(p_view, p_with_texture);
	public function texture_create_from_extension(p_type:gd.renderingdevice.TextureType, p_format:gd.renderingdevice.DataFormat, p_samples:gd.renderingdevice.TextureSamples, p_usage_flags:Int, p_image:Int, p_width:Int, p_height:Int, p_depth:Int, p_layers:Int):gd.RID return __renderingdevice_ptr().value.texture_create_from_extension(p_type, p_format, p_samples, p_usage_flags, p_image, p_width, p_height, p_depth, p_layers);
	public function texture_update(p_texture:gd.RID, p_layer:Int, p_data:gd.PackedByteArray):gd.Error return __renderingdevice_ptr().value.texture_update(p_texture, p_layer, p_data);
	public function texture_get_data(p_texture:gd.RID, p_layer:Int):gd.PackedByteArray return __renderingdevice_ptr().value.texture_get_data(p_texture, p_layer);
	public function texture_is_format_supported_for_usage(p_format:gd.renderingdevice.DataFormat, p_usage_flags:Int):Bool return __renderingdevice_ptr().value.texture_is_format_supported_for_usage(p_format, p_usage_flags);
	public function texture_is_shared(p_texture:gd.RID):Bool return __renderingdevice_ptr().value.texture_is_shared(p_texture);
	public function texture_is_valid(p_texture:gd.RID):Bool return __renderingdevice_ptr().value.texture_is_valid(p_texture);
	public function texture_copy(p_from_texture:gd.RID, p_to_texture:gd.RID, p_from_pos:gd.Vector3, p_to_pos:gd.Vector3, p_size:gd.Vector3, p_src_mipmap:Int, p_dst_mipmap:Int, p_src_layer:Int, p_dst_layer:Int):gd.Error return __renderingdevice_ptr().value.texture_copy(p_from_texture, p_to_texture, p_from_pos, p_to_pos, p_size, p_src_mipmap, p_dst_mipmap, p_src_layer, p_dst_layer);
	public function texture_clear(p_texture:gd.RID, p_color:gd.Color, p_base_mipmap:Int, p_mipmap_count:Int, p_base_layer:Int, p_layer_count:Int):gd.Error return __renderingdevice_ptr().value.texture_clear(p_texture, p_color, p_base_mipmap, p_mipmap_count, p_base_layer, p_layer_count);
	public function texture_resolve_multisample(p_from_texture:gd.RID, p_to_texture:gd.RID):gd.Error return __renderingdevice_ptr().value.texture_resolve_multisample(p_from_texture, p_to_texture);
	public function texture_get_format(p_texture:gd.RID):gd.RDTextureFormat return __renderingdevice_ptr().value.texture_get_format(p_texture);
	public function texture_get_native_handle(p_texture:gd.RID):Int return __renderingdevice_ptr().value.texture_get_native_handle(p_texture);
	public function framebuffer_format_get_texture_samples(p_format:Int, ?p_render_pass:Int = 0):gd.renderingdevice.TextureSamples return __renderingdevice_ptr().value.framebuffer_format_get_texture_samples(p_format, p_render_pass);
	public function framebuffer_get_format(p_framebuffer:gd.RID):Int return __renderingdevice_ptr().value.framebuffer_get_format(p_framebuffer);
	public function framebuffer_is_valid(p_framebuffer:gd.RID):Bool return __renderingdevice_ptr().value.framebuffer_is_valid(p_framebuffer);
	public function sampler_create(p_state:gd.RDSamplerState):gd.RID return __renderingdevice_ptr().value.sampler_create(p_state);
	public function sampler_is_format_supported_for_filter(p_format:gd.renderingdevice.DataFormat, p_sampler_filter:gd.renderingdevice.SamplerFilter):Bool return __renderingdevice_ptr().value.sampler_is_format_supported_for_filter(p_format, p_sampler_filter);
	public function index_array_create(p_index_buffer:gd.RID, p_index_offset:Int, p_index_count:Int):gd.RID return __renderingdevice_ptr().value.index_array_create(p_index_buffer, p_index_offset, p_index_count);
	public function shader_compile_spirv_from_source(p_shader_source:gd.RDShaderSource, ?p_allow_cache:Bool = true):gd.RDShaderSPIRV return __renderingdevice_ptr().value.shader_compile_spirv_from_source(p_shader_source, p_allow_cache);
	public function shader_compile_binary_from_spirv(p_spirv_data:gd.RDShaderSPIRV, ?p_name:std.String = "\"\""):gd.PackedByteArray return __renderingdevice_ptr().value.shader_compile_binary_from_spirv(p_spirv_data, p_name);
	public function shader_create_from_spirv(p_spirv_data:gd.RDShaderSPIRV, ?p_name:std.String = "\"\""):gd.RID return __renderingdevice_ptr().value.shader_create_from_spirv(p_spirv_data, p_name);
	public function shader_create_placeholder():gd.RID return __renderingdevice_ptr().value.shader_create_placeholder();
	public function shader_get_vertex_input_attribute_mask(p_shader:gd.RID):Int return __renderingdevice_ptr().value.shader_get_vertex_input_attribute_mask(p_shader);
	public function uniform_set_is_valid(p_uniform_set:gd.RID):Bool return __renderingdevice_ptr().value.uniform_set_is_valid(p_uniform_set);
	public function buffer_copy(p_src_buffer:gd.RID, p_dst_buffer:gd.RID, p_src_offset:Int, p_dst_offset:Int, p_size:Int):gd.Error return __renderingdevice_ptr().value.buffer_copy(p_src_buffer, p_dst_buffer, p_src_offset, p_dst_offset, p_size);
	public function buffer_update(p_buffer:gd.RID, p_offset:Int, p_size_bytes:Int, p_data:gd.PackedByteArray):gd.Error return __renderingdevice_ptr().value.buffer_update(p_buffer, p_offset, p_size_bytes, p_data);
	public function buffer_clear(p_buffer:gd.RID, p_offset:Int, p_size_bytes:Int):gd.Error return __renderingdevice_ptr().value.buffer_clear(p_buffer, p_offset, p_size_bytes);
	public function buffer_get_data(p_buffer:gd.RID, ?p_offset_bytes:Int = 0, ?p_size_bytes:Int = 0):gd.PackedByteArray return __renderingdevice_ptr().value.buffer_get_data(p_buffer, p_offset_bytes, p_size_bytes);
	public function render_pipeline_is_valid(p_render_pipeline:gd.RID):Bool return __renderingdevice_ptr().value.render_pipeline_is_valid(p_render_pipeline);
	public function compute_pipeline_is_valid(p_compute_pipeline:gd.RID):Bool return __renderingdevice_ptr().value.compute_pipeline_is_valid(p_compute_pipeline);
	public function screen_get_width(?p_screen:Int = 0):Int return __renderingdevice_ptr().value.screen_get_width(p_screen);
	public function screen_get_height(?p_screen:Int = 0):Int return __renderingdevice_ptr().value.screen_get_height(p_screen);
	public function screen_get_framebuffer_format(?p_screen:Int = 0):Int return __renderingdevice_ptr().value.screen_get_framebuffer_format(p_screen);
	public function draw_list_set_blend_constants(p_draw_list:Int, p_color:gd.Color):Void __renderingdevice_ptr().value.draw_list_set_blend_constants(p_draw_list, p_color);
	public function draw_list_bind_render_pipeline(p_draw_list:Int, p_render_pipeline:gd.RID):Void __renderingdevice_ptr().value.draw_list_bind_render_pipeline(p_draw_list, p_render_pipeline);
	public function draw_list_bind_uniform_set(p_draw_list:Int, p_uniform_set:gd.RID, p_set_index:Int):Void __renderingdevice_ptr().value.draw_list_bind_uniform_set(p_draw_list, p_uniform_set, p_set_index);
	public function draw_list_bind_vertex_array(p_draw_list:Int, p_vertex_array:gd.RID):Void __renderingdevice_ptr().value.draw_list_bind_vertex_array(p_draw_list, p_vertex_array);
	public function draw_list_bind_index_array(p_draw_list:Int, p_index_array:gd.RID):Void __renderingdevice_ptr().value.draw_list_bind_index_array(p_draw_list, p_index_array);
	public function draw_list_set_push_constant(p_draw_list:Int, p_buffer:gd.PackedByteArray, p_size_bytes:Int):Void __renderingdevice_ptr().value.draw_list_set_push_constant(p_draw_list, p_buffer, p_size_bytes);
	public function draw_list_draw(p_draw_list:Int, p_use_indices:Bool, p_instances:Int, ?p_procedural_vertex_count:Int = 0):Void __renderingdevice_ptr().value.draw_list_draw(p_draw_list, p_use_indices, p_instances, p_procedural_vertex_count);
	public function draw_list_disable_scissor(p_draw_list:Int):Void __renderingdevice_ptr().value.draw_list_disable_scissor(p_draw_list);
	public function draw_list_switch_to_next_pass():Int return __renderingdevice_ptr().value.draw_list_switch_to_next_pass();
	public function draw_list_switch_to_next_pass_split(p_splits:Int):gd.PackedInt64Array return __renderingdevice_ptr().value.draw_list_switch_to_next_pass_split(p_splits);
	public function draw_list_end():Void __renderingdevice_ptr().value.draw_list_end();
	public function compute_list_begin():Int return __renderingdevice_ptr().value.compute_list_begin();
	public function compute_list_bind_compute_pipeline(p_compute_list:Int, p_compute_pipeline:gd.RID):Void __renderingdevice_ptr().value.compute_list_bind_compute_pipeline(p_compute_list, p_compute_pipeline);
	public function compute_list_set_push_constant(p_compute_list:Int, p_buffer:gd.PackedByteArray, p_size_bytes:Int):Void __renderingdevice_ptr().value.compute_list_set_push_constant(p_compute_list, p_buffer, p_size_bytes);
	public function compute_list_bind_uniform_set(p_compute_list:Int, p_uniform_set:gd.RID, p_set_index:Int):Void __renderingdevice_ptr().value.compute_list_bind_uniform_set(p_compute_list, p_uniform_set, p_set_index);
	public function compute_list_dispatch(p_compute_list:Int, p_x_groups:Int, p_y_groups:Int, p_z_groups:Int):Void __renderingdevice_ptr().value.compute_list_dispatch(p_compute_list, p_x_groups, p_y_groups, p_z_groups);
	public function compute_list_dispatch_indirect(p_compute_list:Int, p_buffer:gd.RID, p_offset:Int):Void __renderingdevice_ptr().value.compute_list_dispatch_indirect(p_compute_list, p_buffer, p_offset);
	public function compute_list_add_barrier(p_compute_list:Int):Void __renderingdevice_ptr().value.compute_list_add_barrier(p_compute_list);
	public function compute_list_end():Void __renderingdevice_ptr().value.compute_list_end();
	public function free_rid(p_rid:gd.RID):Void __renderingdevice_ptr().value.free_rid(p_rid);
	public function capture_timestamp(p_name:std.String):Void __renderingdevice_ptr().value.capture_timestamp(p_name);
	public function get_captured_timestamps_count():Int return __renderingdevice_ptr().value.get_captured_timestamps_count();
	public function get_captured_timestamps_frame():Int return __renderingdevice_ptr().value.get_captured_timestamps_frame();
	public function get_captured_timestamp_gpu_time(p_index:Int):Int return __renderingdevice_ptr().value.get_captured_timestamp_gpu_time(p_index);
	public function get_captured_timestamp_cpu_time(p_index:Int):Int return __renderingdevice_ptr().value.get_captured_timestamp_cpu_time(p_index);
	public function get_captured_timestamp_name(p_index:Int):std.String return __renderingdevice_ptr().value.get_captured_timestamp_name(p_index);
	public function limit_get(p_limit:gd.renderingdevice.Limit):Int return __renderingdevice_ptr().value.limit_get(p_limit);
	public function get_frame_delay():Int return __renderingdevice_ptr().value.get_frame_delay();
	public function submit():Void __renderingdevice_ptr().value.submit();
	public function sync():Void __renderingdevice_ptr().value.sync();
	public function full_barrier():Void __renderingdevice_ptr().value.full_barrier();
	public function create_local_device():gd.RenderingDevice return __renderingdevice_ptr().value.create_local_device();
	public function set_resource_name(p_id:gd.RID, p_name:std.String):Void __renderingdevice_ptr().value.set_resource_name(p_id, p_name);
	public function draw_command_begin_label(p_name:std.String, p_color:gd.Color):Void __renderingdevice_ptr().value.draw_command_begin_label(p_name, p_color);
	public function draw_command_insert_label(p_name:std.String, p_color:gd.Color):Void __renderingdevice_ptr().value.draw_command_insert_label(p_name, p_color);
	public function draw_command_end_label():Void __renderingdevice_ptr().value.draw_command_end_label();
	public function get_device_vendor_name():std.String return __renderingdevice_ptr().value.get_device_vendor_name();
	public function get_device_name():std.String return __renderingdevice_ptr().value.get_device_name();
	public function get_device_pipeline_cache_uuid():std.String return __renderingdevice_ptr().value.get_device_pipeline_cache_uuid();
	public function get_memory_usage(p_type:gd.renderingdevice.MemoryType):Int return __renderingdevice_ptr().value.get_memory_usage(p_type);
	public function get_driver_resource(p_resource:gd.renderingdevice.DriverResource, p_rid:gd.RID, p_index:Int):Int return __renderingdevice_ptr().value.get_driver_resource(p_resource, p_rid, p_index);
}