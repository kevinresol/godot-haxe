package gd;
extern class RenderingDevice extends gd.Object {
	function new(?owner:Dynamic);
	function texture_create_shared(p_view:gd.RDTextureView, p_with_texture:gd.RID):gd.RID;
	function texture_create_from_extension(p_type:gd.renderingdevice.TextureType, p_format:gd.renderingdevice.DataFormat, p_samples:gd.renderingdevice.TextureSamples, p_usage_flags:Int, p_image:Int, p_width:Int, p_height:Int, p_depth:Int, p_layers:Int):gd.RID;
	function texture_update(p_texture:gd.RID, p_layer:Int, p_data:gd.PackedByteArray):gd.Error;
	function texture_get_data(p_texture:gd.RID, p_layer:Int):gd.PackedByteArray;
	function texture_is_format_supported_for_usage(p_format:gd.renderingdevice.DataFormat, p_usage_flags:Int):Bool;
	function texture_is_shared(p_texture:gd.RID):Bool;
	function texture_is_valid(p_texture:gd.RID):Bool;
	function texture_copy(p_from_texture:gd.RID, p_to_texture:gd.RID, p_from_pos:gd.Vector3, p_to_pos:gd.Vector3, p_size:gd.Vector3, p_src_mipmap:Int, p_dst_mipmap:Int, p_src_layer:Int, p_dst_layer:Int):gd.Error;
	function texture_clear(p_texture:gd.RID, p_color:gd.Color, p_base_mipmap:Int, p_mipmap_count:Int, p_base_layer:Int, p_layer_count:Int):gd.Error;
	function texture_resolve_multisample(p_from_texture:gd.RID, p_to_texture:gd.RID):gd.Error;
	function texture_get_format(p_texture:gd.RID):gd.RDTextureFormat;
	function texture_get_native_handle(p_texture:gd.RID):Int;
	function framebuffer_format_get_texture_samples(p_format:Int, ?p_render_pass:Int = 0):gd.renderingdevice.TextureSamples;
	function framebuffer_get_format(p_framebuffer:gd.RID):Int;
	function framebuffer_is_valid(p_framebuffer:gd.RID):Bool;
	function sampler_create(p_state:gd.RDSamplerState):gd.RID;
	function sampler_is_format_supported_for_filter(p_format:gd.renderingdevice.DataFormat, p_sampler_filter:gd.renderingdevice.SamplerFilter):Bool;
	function index_array_create(p_index_buffer:gd.RID, p_index_offset:Int, p_index_count:Int):gd.RID;
	function shader_compile_spirv_from_source(p_shader_source:gd.RDShaderSource, ?p_allow_cache:Bool = true):gd.RDShaderSPIRV;
	function shader_compile_binary_from_spirv(p_spirv_data:gd.RDShaderSPIRV, ?p_name:std.String = "\"\""):gd.PackedByteArray;
	function shader_create_from_spirv(p_spirv_data:gd.RDShaderSPIRV, ?p_name:std.String = "\"\""):gd.RID;
	function shader_create_placeholder():gd.RID;
	function shader_get_vertex_input_attribute_mask(p_shader:gd.RID):Int;
	function uniform_set_is_valid(p_uniform_set:gd.RID):Bool;
	function buffer_copy(p_src_buffer:gd.RID, p_dst_buffer:gd.RID, p_src_offset:Int, p_dst_offset:Int, p_size:Int):gd.Error;
	function buffer_update(p_buffer:gd.RID, p_offset:Int, p_size_bytes:Int, p_data:gd.PackedByteArray):gd.Error;
	function buffer_clear(p_buffer:gd.RID, p_offset:Int, p_size_bytes:Int):gd.Error;
	function buffer_get_data(p_buffer:gd.RID, ?p_offset_bytes:Int = 0, ?p_size_bytes:Int = 0):gd.PackedByteArray;
	function render_pipeline_is_valid(p_render_pipeline:gd.RID):Bool;
	function compute_pipeline_is_valid(p_compute_pipeline:gd.RID):Bool;
	function screen_get_width(?p_screen:Int = 0):Int;
	function screen_get_height(?p_screen:Int = 0):Int;
	function screen_get_framebuffer_format(?p_screen:Int = 0):Int;
	function draw_list_set_blend_constants(p_draw_list:Int, p_color:gd.Color):Void;
	function draw_list_bind_render_pipeline(p_draw_list:Int, p_render_pipeline:gd.RID):Void;
	function draw_list_bind_uniform_set(p_draw_list:Int, p_uniform_set:gd.RID, p_set_index:Int):Void;
	function draw_list_bind_vertex_array(p_draw_list:Int, p_vertex_array:gd.RID):Void;
	function draw_list_bind_index_array(p_draw_list:Int, p_index_array:gd.RID):Void;
	function draw_list_set_push_constant(p_draw_list:Int, p_buffer:gd.PackedByteArray, p_size_bytes:Int):Void;
	function draw_list_draw(p_draw_list:Int, p_use_indices:Bool, p_instances:Int, ?p_procedural_vertex_count:Int = 0):Void;
	function draw_list_disable_scissor(p_draw_list:Int):Void;
	function draw_list_switch_to_next_pass():Int;
	function draw_list_switch_to_next_pass_split(p_splits:Int):gd.PackedInt64Array;
	function draw_list_end():Void;
	function compute_list_begin():Int;
	function compute_list_bind_compute_pipeline(p_compute_list:Int, p_compute_pipeline:gd.RID):Void;
	function compute_list_set_push_constant(p_compute_list:Int, p_buffer:gd.PackedByteArray, p_size_bytes:Int):Void;
	function compute_list_bind_uniform_set(p_compute_list:Int, p_uniform_set:gd.RID, p_set_index:Int):Void;
	function compute_list_dispatch(p_compute_list:Int, p_x_groups:Int, p_y_groups:Int, p_z_groups:Int):Void;
	function compute_list_dispatch_indirect(p_compute_list:Int, p_buffer:gd.RID, p_offset:Int):Void;
	function compute_list_add_barrier(p_compute_list:Int):Void;
	function compute_list_end():Void;
	function free_rid(p_rid:gd.RID):Void;
	function capture_timestamp(p_name:std.String):Void;
	function get_captured_timestamps_count():Int;
	function get_captured_timestamps_frame():Int;
	function get_captured_timestamp_gpu_time(p_index:Int):Int;
	function get_captured_timestamp_cpu_time(p_index:Int):Int;
	function get_captured_timestamp_name(p_index:Int):std.String;
	function limit_get(p_limit:gd.renderingdevice.Limit):Int;
	function get_frame_delay():Int;
	function submit():Void;
	function sync():Void;
	function full_barrier():Void;
	function create_local_device():gd.RenderingDevice;
	function set_resource_name(p_id:gd.RID, p_name:std.String):Void;
	function draw_command_begin_label(p_name:std.String, p_color:gd.Color):Void;
	function draw_command_insert_label(p_name:std.String, p_color:gd.Color):Void;
	function draw_command_end_label():Void;
	function get_device_vendor_name():std.String;
	function get_device_name():std.String;
	function get_device_pipeline_cache_uuid():std.String;
	function get_memory_usage(p_type:gd.renderingdevice.MemoryType):Int;
	function get_driver_resource(p_resource:gd.renderingdevice.DriverResource, p_rid:gd.RID, p_index:Int):Int;
}