package gd;
extern class Input extends gd.Object {
	function new(?owner:Dynamic);
	static final singleton : gd.Input;
	function is_anything_pressed():Bool;
	function is_key_pressed(p_keycode:gd.Key):Bool;
	function is_physical_key_pressed(p_keycode:gd.Key):Bool;
	function is_key_label_pressed(p_keycode:gd.Key):Bool;
	function is_mouse_button_pressed(p_button:gd.MouseButton):Bool;
	function is_joy_button_pressed(p_device:Int, p_button:gd.JoyButton):Bool;
	function is_action_pressed(p_action:std.String, ?p_exact_match:Bool):Bool;
	function is_action_just_pressed(p_action:std.String, ?p_exact_match:Bool):Bool;
	function is_action_just_released(p_action:std.String, ?p_exact_match:Bool):Bool;
	function get_action_strength(p_action:std.String, ?p_exact_match:Bool):Float;
	function get_action_raw_strength(p_action:std.String, ?p_exact_match:Bool):Float;
	function get_axis(p_negative_action:std.String, p_positive_action:std.String):Float;
	function get_vector(p_negative_x:std.String, p_positive_x:std.String, p_negative_y:std.String, p_positive_y:std.String, ?p_deadzone:Float):gd.Vector2;
	function add_joy_mapping(p_mapping:std.String, ?p_update_existing:Bool):Void;
	function remove_joy_mapping(p_guid:std.String):Void;
	function is_joy_known(p_device:Int):Bool;
	function get_joy_axis(p_device:Int, p_axis:gd.JoyAxis):Float;
	function get_joy_name(p_device:Int):std.String;
	function get_joy_guid(p_device:Int):std.String;
	function get_joy_info(p_device:Int):gd.Dictionary;
	function should_ignore_device(p_vendor_id:Int, p_product_id:Int):Bool;
	function get_joy_vibration_strength(p_device:Int):gd.Vector2;
	function get_joy_vibration_duration(p_device:Int):Float;
	function start_joy_vibration(p_device:Int, p_weak_magnitude:Float, p_strong_magnitude:Float, ?p_duration:Float):Void;
	function stop_joy_vibration(p_device:Int):Void;
	function vibrate_handheld(?p_duration_ms:Int, ?p_amplitude:Float):Void;
	function get_gravity():gd.Vector3;
	function get_accelerometer():gd.Vector3;
	function get_magnetometer():gd.Vector3;
	function get_gyroscope():gd.Vector3;
	function set_gravity(p_value:gd.Vector3):Void;
	function set_accelerometer(p_value:gd.Vector3):Void;
	function set_magnetometer(p_value:gd.Vector3):Void;
	function set_gyroscope(p_value:gd.Vector3):Void;
	function get_last_mouse_velocity():gd.Vector2;
	function get_last_mouse_screen_velocity():gd.Vector2;
	function get_mouse_button_mask():Int;
	function set_mouse_mode(p_mode:gd.input.MouseMode):gd.input.MouseMode;
	function get_mouse_mode():gd.input.MouseMode;
	function warp_mouse(p_position:gd.Vector2):Void;
	function action_press(p_action:std.String, ?p_strength:Float):Void;
	function action_release(p_action:std.String):Void;
	function set_default_cursor_shape(?p_shape:gd.input.CursorShape):Void;
	function get_current_cursor_shape():gd.input.CursorShape;
	function set_custom_mouse_cursor(p_image:gd.Resource, ?p_shape:gd.input.CursorShape, ?p_hotspot:gd.Vector2):Void;
	function parse_input_event(p_event:gd.InputEvent):Void;
	function set_use_accumulated_input(p_enable:Bool):Bool;
	function is_using_accumulated_input():Bool;
	function flush_buffered_events():Void;
	function set_emulate_mouse_from_touch(p_enable:Bool):Bool;
	function is_emulating_mouse_from_touch():Bool;
	function set_emulate_touch_from_mouse(p_enable:Bool):Bool;
	function is_emulating_touch_from_mouse():Bool;
	var mouse_mode(get, set) : gd.input.MouseMode;
	var use_accumulated_input(get, set) : Bool;
	function get_use_accumulated_input():Bool;
	var emulate_mouse_from_touch(get, set) : Bool;
	function get_emulate_mouse_from_touch():Bool;
	var emulate_touch_from_mouse(get, set) : Bool;
	function get_emulate_touch_from_mouse():Bool;
}