package gd;
@:include("vector") extern class UtilityFunctions {
	static function sin(p_angle_rad:Float):Float;
	static function cos(p_angle_rad:Float):Float;
	static function tan(p_angle_rad:Float):Float;
	static function sinh(p_x:Float):Float;
	static function cosh(p_x:Float):Float;
	static function tanh(p_x:Float):Float;
	static function asin(p_x:Float):Float;
	static function acos(p_x:Float):Float;
	static function atan(p_x:Float):Float;
	static function atan2(p_y:Float, p_x:Float):Float;
	static function asinh(p_x:Float):Float;
	static function acosh(p_x:Float):Float;
	static function atanh(p_x:Float):Float;
	static function sqrt(p_x:Float):Float;
	static function fmod(p_x:Float, p_y:Float):Float;
	static function fposmod(p_x:Float, p_y:Float):Float;
	static function posmod(p_x:Int, p_y:Int):Int;
	static function floor(p_x:gd.Variant):gd.Variant;
	static function floorf(p_x:Float):Float;
	static function floori(p_x:Float):Int;
	static function ceil(p_x:gd.Variant):gd.Variant;
	static function ceilf(p_x:Float):Float;
	static function ceili(p_x:Float):Int;
	static function round(p_x:gd.Variant):gd.Variant;
	static function roundf(p_x:Float):Float;
	static function roundi(p_x:Float):Int;
	static function abs(p_x:gd.Variant):gd.Variant;
	static function absf(p_x:Float):Float;
	static function absi(p_x:Int):Int;
	static function sign(p_x:gd.Variant):gd.Variant;
	static function signf(p_x:Float):Float;
	static function signi(p_x:Int):Int;
	static function snapped(p_x:gd.Variant, p_step:gd.Variant):gd.Variant;
	static function snappedf(p_x:Float, p_step:Float):Float;
	static function snappedi(p_x:Float, p_step:Int):Int;
	static function pow(p_base:Float, p_exp:Float):Float;
	static function log(p_x:Float):Float;
	static function exp(p_x:Float):Float;
	static function is_nan(p_x:Float):Bool;
	static function is_inf(p_x:Float):Bool;
	static function is_equal_approx(p_a:Float, p_b:Float):Bool;
	static function is_zero_approx(p_x:Float):Bool;
	static function is_finite(p_x:Float):Bool;
	static function ease(p_x:Float, p_curve:Float):Float;
	static function step_decimals(p_x:Float):Int;
	static function lerp(p_from:gd.Variant, p_to:gd.Variant, p_weight:gd.Variant):gd.Variant;
	static function lerpf(p_from:Float, p_to:Float, p_weight:Float):Float;
	static function cubic_interpolate(p_from:Float, p_to:Float, p_pre:Float, p_post:Float, p_weight:Float):Float;
	static function cubic_interpolate_angle(p_from:Float, p_to:Float, p_pre:Float, p_post:Float, p_weight:Float):Float;
	static function cubic_interpolate_in_time(p_from:Float, p_to:Float, p_pre:Float, p_post:Float, p_weight:Float, p_to_t:Float, p_pre_t:Float, p_post_t:Float):Float;
	static function cubic_interpolate_angle_in_time(p_from:Float, p_to:Float, p_pre:Float, p_post:Float, p_weight:Float, p_to_t:Float, p_pre_t:Float, p_post_t:Float):Float;
	static function bezier_interpolate(p_start:Float, p_control_1:Float, p_control_2:Float, p_end:Float, p_t:Float):Float;
	static function bezier_derivative(p_start:Float, p_control_1:Float, p_control_2:Float, p_end:Float, p_t:Float):Float;
	static function angle_difference(p_from:Float, p_to:Float):Float;
	static function lerp_angle(p_from:Float, p_to:Float, p_weight:Float):Float;
	static function inverse_lerp(p_from:Float, p_to:Float, p_weight:Float):Float;
	static function remap(p_value:Float, p_istart:Float, p_istop:Float, p_ostart:Float, p_ostop:Float):Float;
	static function smoothstep(p_from:Float, p_to:Float, p_x:Float):Float;
	static function move_toward(p_from:Float, p_to:Float, p_delta:Float):Float;
	static function rotate_toward(p_from:Float, p_to:Float, p_delta:Float):Float;
	static function deg_to_rad(p_deg:Float):Float;
	static function rad_to_deg(p_rad:Float):Float;
	static function linear_to_db(p_lin:Float):Float;
	static function db_to_linear(p_db:Float):Float;
	static function wrap(p_value:gd.Variant, p_min:gd.Variant, p_max:gd.Variant):gd.Variant;
	static function wrapi(p_value:Int, p_min:Int, p_max:Int):Int;
	static function wrapf(p_value:Float, p_min:Float, p_max:Float):Float;
	static function max(p_arg1:gd.Variant, p_arg2:gd.Variant, p_args:haxe.Rest<gd.Variant>):gd.Variant;
	static function maxi(p_a:Int, p_b:Int):Int;
	static function maxf(p_a:Float, p_b:Float):Float;
	static function min(p_arg1:gd.Variant, p_arg2:gd.Variant, p_args:haxe.Rest<gd.Variant>):gd.Variant;
	static function mini(p_a:Int, p_b:Int):Int;
	static function minf(p_a:Float, p_b:Float):Float;
	static function clamp(p_value:gd.Variant, p_min:gd.Variant, p_max:gd.Variant):gd.Variant;
	static function clampi(p_value:Int, p_min:Int, p_max:Int):Int;
	static function clampf(p_value:Float, p_min:Float, p_max:Float):Float;
	static function nearest_po2(p_value:Int):Int;
	static function pingpong(p_value:Float, p_length:Float):Float;
	static function randomize():Void;
	static function randi():Int;
	static function randf():Float;
	static function randi_range(p_from:Int, p_to:Int):Int;
	static function randf_range(p_from:Float, p_to:Float):Float;
	static function randfn(p_mean:Float, p_deviation:Float):Float;
	static function seed(p_base:Int):Void;
	static function rand_from_seed(p_seed:Int):gd.PackedInt64Array;
	static function weakref(p_obj:gd.Variant):gd.Variant;
	static function typeof(p_variable:gd.Variant):Int;
	static function type_convert(p_variant:gd.Variant, p_type:Int):gd.Variant;
	static function str(p_arg1:gd.Variant, p_args:haxe.Rest<gd.Variant>):std.String;
	static function error_string(p_error:Int):std.String;
	static function type_string(p_type:Int):std.String;
	static function print(p_arg1:gd.Variant, p_args:haxe.Rest<gd.Variant>):Void;
	static function print_rich(p_arg1:gd.Variant, p_args:haxe.Rest<gd.Variant>):Void;
	static function printerr(p_arg1:gd.Variant, p_args:haxe.Rest<gd.Variant>):Void;
	static function printt(p_arg1:gd.Variant, p_args:haxe.Rest<gd.Variant>):Void;
	static function prints(p_arg1:gd.Variant, p_args:haxe.Rest<gd.Variant>):Void;
	static function printraw(p_arg1:gd.Variant, p_args:haxe.Rest<gd.Variant>):Void;
	static function print_verbose(p_arg1:gd.Variant, p_args:haxe.Rest<gd.Variant>):Void;
	static function push_error(p_arg1:gd.Variant, p_args:haxe.Rest<gd.Variant>):Void;
	static function push_warning(p_arg1:gd.Variant, p_args:haxe.Rest<gd.Variant>):Void;
	static function var_to_str(p_variable:gd.Variant):std.String;
	static function str_to_var(p_string:std.String):gd.Variant;
	static function var_to_bytes(p_variable:gd.Variant):gd.PackedByteArray;
	static function bytes_to_var(p_bytes:gd.PackedByteArray):gd.Variant;
	static function var_to_bytes_with_objects(p_variable:gd.Variant):gd.PackedByteArray;
	static function bytes_to_var_with_objects(p_bytes:gd.PackedByteArray):gd.Variant;
	static function hash(p_variable:gd.Variant):Int;
	static function instance_from_id(p_instance_id:Int):gd.Object;
	static function is_instance_id_valid(p_id:Int):Bool;
	static function is_instance_valid(p_instance:gd.Variant):Bool;
	static function rid_allocate_id():Int;
	static function rid_from_int64(p_base:Int):gd.RID;
	static function is_same(p_a:gd.Variant, p_b:gd.Variant):Bool;
}